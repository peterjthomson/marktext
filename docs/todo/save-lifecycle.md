# Save lifecycle (renderer ↔ main) and Light Touch baseline

This note documents how “save” works today across the renderer (`src/renderer/src/store/editor.js`) and main process (`src/main/menu/actions/file.js`), and why **Light Touch** needed a small baseline fix to avoid “drift” across repeated saves.

This is a **TODO/working** document: it captures current behavior (including quirks) and outlines follow-ups to improve correctness and clarity.

## Key concepts

- **`tab.markdown`**: the current markdown string in the renderer (often regenerated by Muya).
- **`tab.originalMarkdown`**: the “baseline” markdown used by Light Touch mode. It starts as the markdown loaded from disk and is intended to advance to the last successfully-saved markdown.
- **Light Touch mode** (`getMarkdownForSave`): computes `markdownToSave` from `(tab.markdown, tab.originalMarkdown)` so we can preserve unchanged formatting.

## IPC events involved (current)

### Renderer → Main

- **`mt::response-file-save`**: `(id, filename, pathname, markdown, options, defaultPath)`
  - Used for manual save and auto-save.
- **`mt::response-file-save-as`**: `(id, filename, pathname, markdown, options, defaultPath)`
  - Used for “Save As…”.
- **`mt::save-tabs`**: `unsavedFiles[]` where each entry includes `{ id, filename, pathname, markdown, options, defaultPath }`
  - Used for “Save All”.
- **`mt::close-window-confirm`**: `unsavedFiles[]` (same shape as above)
  - Used when closing a window with unsaved tabs.

### Main → Renderer

- **`mt::tab-saved`**: `(tabId)`
  - Indicates “saved” in multiple situations (see “Known smells / issues”).
- **`mt::set-pathname`**: `{ id, pathname, filename }`
  - Sent when a save results in a new path (first save, or save-as to a new path).
- **`mt::tab-save-failure`**: `(tabId, message)`

## Lifecycle: manual save (existing file on disk)

1. Renderer computes `markdownToSave`:
   - If Light Touch is enabled and content is “semantically identical”, it may pick the original markdown.
   - Otherwise it may merge to preserve unchanged lines.
2. Renderer sends `mt::response-file-save(..., markdownToSave, ...)` to main.
3. Main writes the file and responds with `mt::tab-saved(tabId)`.
4. Renderer marks the tab saved and updates `tab.originalMarkdown` to match the last successful save.

### Why this matters for Light Touch

Light Touch is only stable if **`originalMarkdown` advances to the markdown that was actually written**. Otherwise, later saves can “forget” the preserved formatting.

## The drift bug (what was happening)

Before the minimal fix, the renderer updated the Light Touch baseline like this after a save:

- `tab.originalMarkdown = tab.markdown`

But `tab.markdown` is the **regenerated** markdown from Muya, while the main process may have written **`markdownToSave`**, which can intentionally preserve original formatting.

Result: after one save, subsequent Light Touch saves would use the regenerated markdown as the baseline, causing formatting preservation to be lost over time (“drift”).

## Minimal fix applied (baseline follows saved content)

The renderer now tracks the exact payload it asked main to write (primarily for saves to an existing path, i.e. no file dialog), and uses that to refresh the Light Touch baseline on successful save notifications:

- A module-scope map **`pendingSavedMarkdown`** tracks `{ tabId -> markdownToSave }` for in-flight saves.
- On `mt::tab-saved` and `mt::set-pathname`, we set:
  - `tab.originalMarkdown = pendingSavedMarkdown.get(id) ?? tab.markdown`
  - then clear the map entry.

This ensures **the Light Touch baseline becomes the last saved markdown**, preventing drift across repeated saves.

## Known smells / issues (not fixed here)

These are potential correctness issues and code smells worth sweeping more broadly:

- **`mt::tab-saved` conflates success and cancel**:
  - In the main process, “Save”/“Save As…” dialog cancellation can still emit `mt::tab-saved(tabId)` to clear UI state.
  - The renderer currently treats `mt::tab-saved` as success (sets `isSaved = true`).
  - This is likely a correctness bug (and could lead to data loss on close prompts).
- **Save success events don’t carry “what was saved”**:
  - The renderer has to infer the saved content/baseline from local state.
  - This is fragile with async saves (edits during save) and Light Touch logic.

## Follow-ups (suggested direction)

- **Split “saved” vs “cancelled”** in IPC:
  - e.g. `mt::tab-save-complete` with `{ id, status: 'saved'|'cancelled'|'failed' }`
  - or separate `mt::tab-save-cancelled`.
- **Include saved payload (or a checksum/version)** in save completion events:
  - e.g. `mt::tab-saved` carries `{ id, savedMarkdown }` (or a hash) so baseline updates are exact.
- **Consider a per-tab “save version”**:
  - Increment a `tab.saveVersion` on each request and echo it back on completion to avoid race issues.

